// Copyright (c) 2023-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"time"

	"github.com/mattermost/mattermost-plugin-ai/api"
	"github.com/mattermost/mattermost-plugin-ai/bots"
	"github.com/mattermost/mattermost-plugin-ai/config"
	"github.com/mattermost/mattermost-plugin-ai/conversations"
	"github.com/mattermost/mattermost-plugin-ai/database"
	"github.com/mattermost/mattermost-plugin-ai/enterprise"
	"github.com/mattermost/mattermost-plugin-ai/i18n"
	"github.com/mattermost/mattermost-plugin-ai/indexer"
	"github.com/mattermost/mattermost-plugin-ai/llm"
	"github.com/mattermost/mattermost-plugin-ai/llmcontext"
	"github.com/mattermost/mattermost-plugin-ai/mcp"
	"github.com/mattermost/mattermost-plugin-ai/meetings"
	"github.com/mattermost/mattermost-plugin-ai/metrics"
	"github.com/mattermost/mattermost-plugin-ai/mmapi"
	"github.com/mattermost/mattermost-plugin-ai/mmtools"
	"github.com/mattermost/mattermost-plugin-ai/prompts"
	"github.com/mattermost/mattermost-plugin-ai/search"
	"github.com/mattermost/mattermost-plugin-ai/streaming"
	"github.com/mattermost/mattermost/server/public/model"
	"github.com/mattermost/mattermost/server/public/plugin"
	"github.com/mattermost/mattermost/server/public/pluginapi"
	"github.com/mattermost/mattermost/server/public/shared/httpservice"
)

func main() {
	plugin.ClientMain(&Plugin{})
}

type Plugin struct {
	plugin.MattermostPlugin

	configuration config.Container

	pluginAPI            *pluginapi.Client
	apiService           *api.API
	indexerService       *indexer.Indexer
	conversationsService *conversations.Conversations
	mcpClientManager     *mcp.ClientManager
}

func (p *Plugin) OnActivate() error {
	pluginAPI := pluginapi.NewClient(p.API, p.Driver)
	mmClient := mmapi.NewClient(pluginAPI)
	licenseChecker := enterprise.NewLicenseChecker(pluginAPI)
	dbClient := mmapi.NewDBClient(pluginAPI)

	i18nBundle := i18n.Init()

	llmUpstreamHTTPClient := httpservice.MakeHTTPServicePlugin(p.API).MakeClient(true)
	llmUpstreamHTTPClient.Timeout = time.Minute * 10 // LLM requests can be slow

	untrustedHTTPClient := httpservice.MakeHTTPServicePlugin(p.API).MakeClient(false)

	metricsService := metrics.NewMetrics(metrics.InstanceInfo{
		InstallationID: os.Getenv("MM_CLOUD_INSTALLATION_ID"),
		PluginVersion:  manifest.Version, // Manifest imported from manifest.go which is generated by the build process
	})

	updated, newCfg, err := migrateServicesToBots(p.API, pluginAPI, *p.configuration.Config())
	if err != nil {
		pluginAPI.Log.Error("failed to migrate services to bots", "error", err)
		// Don't fail on migration errors
	}
	if updated && err == nil {
		p.configuration.Update(&newCfg)
	}

	bots := bots.New(p.API, pluginAPI, licenseChecker, &p.configuration, llmUpstreamHTTPClient)
	p.configuration.RegisterUpdateListener(func() {
		if ensureErr := bots.EnsureBots(p.configuration.GetBots()); ensureErr != nil {
			pluginAPI.Log.Error("failed to ensure bots on configuration update", "error", ensureErr)
			return
		}
	})

	if ensureBotsErr := bots.EnsureBots(newCfg.Bots); ensureBotsErr != nil {
		// If we fail to ensure bots, we log the error but do not return
		// as it would leave the plugin in a state where it can't be configured from the system console.
		pluginAPI.Log.Error("failed to ensure bots", "error", ensureBotsErr)
	}

	if setupTablesErr := database.SetupTables(dbClient.DB); setupTablesErr != nil {
		pluginAPI.Log.Error("failed to setup database tables", "error", setupTablesErr)
		return setupTablesErr
	}

	prompts, promptManagerErr := llm.NewPrompts(prompts.PromptsFolder)
	if promptManagerErr != nil {
		pluginAPI.Log.Error("failed to initialize prompts", "error", promptManagerErr)
		return promptManagerErr
	}

	streamingService := streaming.NewMMPostStreamService(mmClient, i18nBundle)

	embeddingsSearch, err := search.InitEmbeddingsSearch(
		dbClient.DB,
		llmUpstreamHTTPClient,
		p.configuration.EmbeddingSearchConfig(),
		licenseChecker,
	)
	if err != nil {
		pluginAPI.Log.Error("failed to initialize search infrastructure", "error", err)
		// Continue without search functionality
	}

	indexerService := indexer.New(embeddingsSearch, mmClient, bots, dbClient.DB)

	searchService := search.New(
		embeddingsSearch,
		mmClient,
		prompts,
		streamingService,
		licenseChecker,
	)

	toolProvider := mmtools.NewMMToolProvider(
		mmClient,
		searchService,
		untrustedHTTPClient,
	)

	// Build redirect URI
	siteURL := pluginAPI.Configuration.GetConfig().ServiceSettings.SiteURL
	if siteURL == nil || *siteURL == "" {
		return fmt.Errorf("site URL not configured")
	}
	manifestID := manifest.Id
	oauthCallbackURL := fmt.Sprintf("%s/plugins/%s/oauth/callback", *siteURL, manifestID)

	mcpClientManager := mcp.NewClientManager(p.configuration.MCP(), pluginAPI.Log, pluginAPI, mcp.NewOAuthManager(mmClient, oauthCallbackURL))
	p.configuration.RegisterUpdateListener(func() {
		mcpClientManager.ReInit(p.configuration.MCP())
	})

	contextBuilder := llmcontext.NewLLMContextBuilder(
		pluginAPI,
		toolProvider,
		mcpClientManager,
		&p.configuration,
	)

	conversationsService := conversations.New(
		prompts,
		mmClient,
		streamingService,
		contextBuilder,
		bots,
		dbClient,
		licenseChecker,
		i18nBundle,
		nil, // meetingsService will be set after it's created
	)

	meetingsService := meetings.NewService(
		pluginAPI,
		streamingService,
		prompts,
		bots,
		i18nBundle,
		metricsService,
		dbClient,
		contextBuilder,
		conversationsService,
	)

	// Set the meetings service on conversations to break circular dependency
	// TODO: Refactor to avoid circular dependency
	conversationsService.SetMeetingsService(meetingsService)

	apiService := api.New(
		bots,
		conversationsService,
		meetingsService,
		indexerService,
		searchService,
		pluginAPI,
		metricsService,
		contextBuilder,
		&p.configuration,
		prompts,
		mmClient,
		dbClient,
		licenseChecker,
		streamingService,
		i18nBundle,
		mcpClientManager,
	)

	// Keep only what we need
	p.pluginAPI = pluginAPI
	p.apiService = apiService
	p.indexerService = indexerService
	p.conversationsService = conversationsService
	p.mcpClientManager = mcpClientManager

	return nil
}

func (p *Plugin) OnDeactivate() error {
	// Clean up MCP client manager if it exists
	p.mcpClientManager.Close()
	return nil
}

func (p *Plugin) MessageHasBeenPosted(c *plugin.Context, post *model.Post) {
	// Index the new message in the vector database
	if p.indexerService != nil {
		// Get channel to retrieve team ID
		channel, err := p.API.GetChannel(post.ChannelId)
		if err != nil {
			p.pluginAPI.Log.Error("Failed to get channel for post indexing", "error", err)
		} else {
			if err := p.indexerService.IndexPost(context.Background(), post, channel); err != nil {
				p.pluginAPI.Log.Error("Failed to index post in vector database", "error", err)
			}
		}
	}

	p.conversationsService.MessageHasBeenPosted(c, post)
}

func (p *Plugin) MessageHasBeenUpdated(c *plugin.Context, newPost, oldPost *model.Post) {
	// Handle indexing of updated posts
	if p.indexerService != nil {
		// Delete the old post from index
		if err := p.indexerService.DeletePost(context.Background(), oldPost.Id); err != nil {
			p.pluginAPI.Log.Error("Failed to delete post from vector database", "error", err)
		}

		// Get channel to retrieve team ID
		channel, err := p.API.GetChannel(newPost.ChannelId)
		if err != nil {
			p.pluginAPI.Log.Error("Failed to get channel for post indexing", "error", err)
		} else {
			// Index the updated post
			if err := p.indexerService.IndexPost(context.Background(), newPost, channel); err != nil {
				p.pluginAPI.Log.Error("Failed to index updated post in vector database", "error", err)
			}
		}
	}
}

func (p *Plugin) ServeHTTP(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	p.apiService.ServeHTTP(c, w, r)
}

func (p *Plugin) ServeMetrics(c *plugin.Context, w http.ResponseWriter, r *http.Request) {
	p.apiService.ServeMetrics(c, w, r)
}
